from __future__ import annotations
from ast import Constant

from typing import Dict, List, Set, Tuple, Optional

from lang.utils import getExpressionsInStatement, getVarsUsedInExpression, getExpressionsInCFG, getExpressionsInExpression

from .analysis import Analysis
from lang.cfg import Entry, Exit, InnerNode, Node, CFG

from lang.ast import Assignment, Statement, Guard, Variable, Expression, BinaryExpression, UnaryExpression, ConstantExpression, BooleanConstant, IntegerConstant

AnalysisType = Set[Expression] 

#forward analysis
#must analysis
#intersection
class AvailableExpressions(Analysis[AnalysisType]):
        def __init__(self, CFG):
            #set of all expressions in program
            self.AllExpressions = getExpressionsInCFG(CFG)

        def initial_in(self, node: Node) -> AnalysisType:
            return set() 

        def initial_out(self, node: Node) -> AnalysisType:
            if isinstance(node, Entry): # boundary
                return set() 
            else:  # initialize all nodes except for the boundary
                return self.AllExpressions

        # new avaliable_in and available_out for a given node in some iteration
        def get_new_values(self, node: Node, predecessors_out: List[AnalysisType], successors_in: List[AnalysisType], curr_out: Dict[Node, AnalysisType], curr_in: Dict[Node, AnalysisType]) -> Tuple[AnalysisType, AnalysisType]:

            """ 
            Return tuple (In, Out), 
            computed using this node's predessors' Outs (`predecessors_out`)
            """
            # Used
            # gen: available expression e generated by a statement - evaluates e and doesn't later write variables used in e
            # kill: available expressions killed by a statement
            Gen = set() 
            Kill = set() 
            In = set()
            Out = set()
            # Update Gen and Kill, depending on Node type 
            if isinstance(node, Entry):
                pass
            else:
                if isinstance(node, Exit):
                    In = self.AllExpressions.intersection(*predecessors_out)
                elif isinstance(node.statement, Guard):
                    # case 1: y > m and !x and 1 and !1 (y > m and !1, !x will be taken into cosideration but not 1)
                    In = self.AllExpressions.intersection(*predecessors_out)
                    Gen = getExpressionsInStatement(node.statement)
                elif isinstance(node.statement, Assignment):
                    # python cannot assign to operationr so i didn't consider case x + y = ...
                    # case 2: k = x + y  and no expression envolves k in IN[B]
                    # case 3: k = x + y  and exists expression envolves k in IN[B]
                    # case 4: x = x + y i.e. x is used and x is redefined - don't add x+ y, kill all expressions involve x
                    # case 5: k = x + (y+z), y + z is not in IN[B], add x + (y + z), y+z into Gen

                    # find variable written in the statement 
                    In = self.AllExpressions.intersection(*predecessors_out)
                    # gain variable assigned values
                    WrittenVar = node.statement.variable  
                    # gain all expressions used in this block, including nested expressions
                    Used = getExpressionsInExpression(node.statement.value)
                    #set of expressions in IN[B] to be killed
                    Kill = set(filter(lambda expression: WrittenVar in getVarsUsedInExpression(expression), In))
                    #accommodate with senario that variables used in rhs expression is redefined in lhs, then these used expressions won't be added 
                    Gen = Used.difference(set(filter(lambda expression: (WrittenVar in getVarsUsedInExpression(expression)), Used)))
                    
                else: 
                    raise Exception(
                    f"Node {node} with statement of type {type(node.statement)} not supported in {type(self).__name__}'s get_new_values method.")
            
            # calculate OUT[B] by F(IN[B])
            Out = In.difference(Kill).union(Gen)
            
            return (In, Out)


